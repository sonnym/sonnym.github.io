<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    Barebones Architecture in Elm &middot; effluence
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/hyde.css">
  <link rel="stylesheet" href="/css/custom.css">

  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="layout-reverse">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>effluence</h1>
      <p class="lead"></p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/">home</a>
      </li>

      

      
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">about</a>
            </li>
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/projects/">projects</a>
            </li>
          
        
      
        
          
        
      

      <li class="sidebar-nav-item">
        <a href="/atom.xml" target="_blank">rss</a>
      </li>
    </ul>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Barebones Architecture in Elm</h1>
  <h2>Motivation and Background</h2>

<p>In the process of writing larger applications in
<a href="http://elm-lang.org/" target="_blank">Elm</a>,
I find it far too easy to initially focus on one small part of the problem
while losing perspective on the bigger picture. For instance, I will begin by
rendering a simple scene, followed by splitting out components, and finally
adding in signals.  While this is generally a good approach, in my mind,
it is sometimes difficult to retrofit patterns onto the basis of the application
I have already written.</p>

<p>There are some really excellent resources covering the architecture of applications
in the Elm language. The
<a href="http://elm-lang.org/learn/Architecture.elm" target="_blank">canonical article</a>
on the subject can be found on the official Elm site and covers everything at
a high level. The best example is likely
<a href="https://evancz.github.io/elm-todomvc/" target="_blank">TodoMVC</a>
(<a href="https://github.com/evancz/elm-todomvc" target="_blank">source</a>)
ported to Elm which uses many the concepts from the article to create a rich
and simple interface, showcasing just how powerful Elm is.  Another great and
extremely polished example is
<a href="http://dreamwriter.io/" target="_blank">Dreamwriter</a>
(<a href="https://github.com/rtfeldman/dreamwriter" target="_blank">source</a>),
which also incorporates the separation of components as outlined in the original
article.</p>

<p>The only problem with these examples, and the theory behind them, is that they
are too fleshed out, too complete. It is difficult to extract the core concepts
from the specific details of the problem they are solving. In attempting to
retrofit this pattern onto my own programs, I had to remove everything
extraneous and reduce the implementation to the fundamentals.</p>

<h2>A Simple Example</h2>

<p>First, I will present the source and result of a very, very basic (practically
trivial) user interface in Elm. It consists of nothing more that a button
that increments a value, but this simple scene gives us the foundation  upon
which we can build larger applications.</p>

<h4>barebones_architecture.elm</h4>

<h5>Source</h5>

<div class="highlight"><pre><code class="language-elm" data-lang="elm"><span class="kn">import </span><span class="nc">Signal</span>

<span class="kn">import </span><span class="nc">Text</span>

<span class="kn">import </span><span class="nc">Graphics.Input</span> <span class="kr">as</span> <span class="kt">Input</span>

<span class="kn">import </span><span class="nc">Graphics.Element</span> <span class="p">(</span><span class="kt">Element</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">Graphics.Element</span> <span class="kr">as</span> <span class="kt">Element</span>

<span class="kr">type</span> <span class="kr">alias</span> <span class="kt">State</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">value</span><span class="nf">:</span> <span class="kt">Int</span> <span class="p">}</span>

<span class="kr">type</span> <span class="kt">Action</span>
  <span class="nf">=</span> <span class="kt">NoOp</span>
  <span class="nf">|</span> <span class="kt">Increment</span>

<span class="kr">main </span><span class="nf">:</span> <span class="kt">Signal</span> <span class="kt">Element</span>
<span class="kr">main </span><span class="nf">=</span> <span class="kt">Signal</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">scene</span> <span class="nv">state</span>

<span class="nv">scene</span> <span class="nf">:</span> <span class="kt">State</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">scene</span> <span class="nv">state</span> <span class="nf">=</span>
  <span class="kt">Element</span><span class="nf">.</span><span class="nv">flow</span> <span class="kt">Element</span><span class="nf">.</span><span class="nv">down</span> <span class="p">[</span><span class="nv">incrementButton</span><span class="p">,</span> <span class="p">(</span><span class="kt">Text</span><span class="nf">.</span><span class="nv">asText</span> <span class="nv">state</span><span class="nf">.</span><span class="nv">value</span><span class="p">)]</span>

<span class="nv">state</span> <span class="nf">:</span> <span class="kt">Signal</span> <span class="kt">State</span>
<span class="nv">state</span> <span class="nf">=</span> <span class="kt">Signal</span><span class="nf">.</span><span class="nv">foldp</span> <span class="nv">step</span> <span class="nv">initialState</span> <span class="p">(</span><span class="kt">Signal</span><span class="nf">.</span><span class="nv">subscribe</span> <span class="nv">actions</span><span class="p">)</span>

<span class="nv">step</span> <span class="nf">:</span> <span class="kt">Action</span> <span class="nf">-&gt;</span> <span class="kt">State</span> <span class="nf">-&gt;</span> <span class="kt">State</span>
<span class="nv">step</span> <span class="nv">action</span> <span class="nv">state</span> <span class="nf">=</span>
  <span class="kr">case</span> <span class="nv">action</span> <span class="kr">of</span>
    <span class="kt">NoOp</span> <span class="nf">-&gt;</span> <span class="nv">state</span>
    <span class="kt">Increment</span> <span class="nf">-&gt;</span> <span class="p">{</span> <span class="nv">state</span> <span class="nf">|</span> <span class="nv">value</span> <span class="nf">&lt;-</span> <span class="nv">state</span><span class="nf">.</span><span class="nv">value</span> <span class="nf">+</span> <span class="mi">1</span> <span class="p">}</span>

<span class="nv">initialState</span> <span class="nf">:</span> <span class="kt">State</span>
<span class="nv">initialState</span> <span class="nf">=</span> <span class="p">{</span> <span class="nv">value</span> <span class="nf">=</span> <span class="mi">0</span> <span class="p">}</span>

<span class="nv">actions</span> <span class="nf">:</span> <span class="kt">Signal</span><span class="nf">.</span><span class="kt">Channel</span> <span class="kt">Action</span>
<span class="nv">actions</span> <span class="nf">=</span> <span class="kt">Signal</span><span class="nf">.</span><span class="nv">channel</span> <span class="kt">NoOp</span>

<span class="nv">incrementButton</span> <span class="nf">:</span> <span class="kt">Element</span>
<span class="nv">incrementButton</span> <span class="nf">=</span>
  <span class="kt">Input</span><span class="nf">.</span><span class="nv">button</span> <span class="p">(</span><span class="kt">Signal</span><span class="nf">.</span><span class="nv">send</span> <span class="nv">actions</span> <span class="kt">Increment</span><span class="p">)</span> <span class="s">&quot;Increment&quot;</span></code></pre></div>

<h5>Result</h5>

<iframe src="/examples/elm/barebones_architecture.html" frameBorder="0" onload="this.height = this.contentWindow.document.body.scrollHeight + 'px';this.width = this.contentWindow.document.body.scrollWidth + 'px'"></iframe>

<h2>The Moving Parts</h2>

<p>This example consists of the four core components for any such application:</p>

<ol>
<li>User input represented as a union type</li>
<li>A signal channel for passing messages generated by user input</li>
<li>State dependence on a subscription to that channel</li>
<li>Rendering a scene based on the current state</li>
</ol>

<p>We will discuss each in turn.</p>

<h3>User Input Union Type</h3>

<p>Most applications are not very interesting without user input. We choose to
represent all user input as a
<a href="http://elm-lang.org/learn/Union-Types.elm" target="_blank">union type</a>
This gives us the ability to easily
<a href="https://en.wikipedia.org/wiki/Pattern_matching" target="_blank">pattern match</a>
on the user action in a case statement, which will be useful very soon. In this
particular example, the <code>Action</code> type can only consist of either a <code>NoOp</code> or
<code>Increment</code>.</p>

<h3>Signal Channel for Message Passing</h3>

<p>We then create a
<a href="http://elm-lang.org/blog/announce/0.14.elm#signal-channels" target="_blank">signal channel</a>
of actions. The <code>actions</code> method creates a new channel that will default to the
<code>NoOp</code> value. The <code>incrementButton</code> function creates a new button that will send
the <code>Increment</code> value to the channel.</p>

<h3>Subscribing and Updating State</h3>

<p>The <code>state</code> function begins to really pull all the pieces together. Here, we
use <code>Signal.foldp</code> to create a past-dependent <code>Signal State</code>. The <code>State</code> type
alias is defined as having only one field, a <code>value</code> of type <code>Int</code>. We start
with an <code>initialState</code> where the <code>value</code> field is set to zero. The signal we
provide to the <code>foldp</code> function is the result of passing the <code>actions</code> channel
to the <code>Signal.subscribe</code> function.</p>

<p>We then define a <code>step</code> function, of type <code>Action -&gt; State -&gt; State</code>. Because
of the pattern matching on union types, the case statement is very simple to
follow: if the action parameter is a <code>NoOp</code>, simply return the original state,
but if it is an <code>Increment</code> action, return a new <code>State</code> record with its
<code>value</code> increased by one.</p>

<h3>Rendering a State Dependent Scene</h3>

<p>The final piece of glue is very typical in Elm, the <code>main</code> function of type
<code>Signal Element</code>. In this very simple example, we are using <code>Signal.map</code> to
call <code>scene</code> with the current state.</p>

<h2>Extensibility</h2>

<p>While this example does not actually do particularly much, that is precisely
the point. You can transparently observe how the pieces fit together to make
up the core of the application. In practice, there are many more steps to be
made, but the general principles remain the same:</p>

<ol>
<li>A central location for state in the application</li>
<li>Accepting user input to mutate that state</li>
<li>Outputting some representation of that state</li>
</ol>

<p>Generally speaking, to add real functionality, we only need to add more values
to the <code>Action</code> union type, extend the case statement in <code>step</code>, and create
more sources of input like <code>incrementButton</code>. In reality, however, our
applications will be much more maintainable if we create separate components
and nested <code>Action</code> and <code>State</code> types (which the
<a href="http://elm-lang.org/learn/Architecture.elm#nesting" target="_blank">architecture article</a>
covers in detail).</p>

<p>In conclusion, the basic pattern that is being used in more complex and feature
rich Elm applications can be distilled to very little, but is an extremely
powerful concept that can be extended to a great degree. This is the case to
such a degree that I will likely start with a core similar to this, rather than
some trivial scene, when writing new applications.</p>

  <span class="post-date">23 Dec 2014</span>
</div>



    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-47296801-1', 'sonnym.github.io');
      ga('send', 'pageview');
    </script>

  </body>
</html>
