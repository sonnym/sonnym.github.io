<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"> <head> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Lazy Ruby &middot; effluence </title> <link rel="stylesheet" href="/css/poole.css"> <link rel="stylesheet" href="/css/syntax.css"> <link rel="stylesheet" href="/css/hyde.css"> <link rel="stylesheet" href="/css/custom.css"> <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> </head> <body class="layout-reverse"> <div class="sidebar"> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1>effluence</h1> <p class="lead"></p> </div> <ul class="sidebar-nav"> <li class="sidebar-nav-item"> <a href="/">home</a> </li> <li class="sidebar-nav-item"> <a href="/about/">about</a> </li> <li class="sidebar-nav-item"> <a href="/atom.xml" target="_blank">rss</a> </li> </ul> <p><a href="https://twitter.com/mnemosyne_speak" target="_blank">@mnemosyne_speak</a></p> <p>&copy; 2018. All rights reserved.</p> </div> </div> <div class="content container"> <div class="post"> <h1 class="post-title">Lazy Ruby</h1> <h2>Lazy Evaluation and Recursive Lists</h2> <p>In Haskell, it is possible to construct infinite lists via recursive definition. This is only possible because Haskell uses <span> <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> <span style="vertical-align: super"> <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 12 16" version="1.1" width="12" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z"/></svg></a> </span> </span> rather than eager evaluation. Otherwise, the entire list would need to be calculated and the program would never terminate.</p> <p>Because Haskell makes it easy to define lists and is lazy, the code for defining an infinite series is very simple. The following list represents the fibonacci sequence.</p> <figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kt">:</span> <span class="mi">1</span> <span class="kt">:</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span></code></pre></figure> <p>The list is defined recursively; the first two values are one, and every subsequent value is the sum of zipping the entire list with the tail of the list, evaluating to the sum of the two previous number for any position beyond the second. Pulling numbers off the list is as easy as the following.</p> <figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span></span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="n">fibs</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">34</span><span class="p">,</span><span class="mi">55</span><span class="p">]</span></code></pre></figure> <p>I was originally exposed to this concept while reading the book <span> <a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/">Programming Languages: Application and Interpretation</a> <span style="vertical-align: super"> <a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 12 16" version="1.1" width="12" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z"/></svg></a> </span> </span> which provides a more thorough introduction to the topic of lazy evaluation.</p> <h2>Spurious Examples and Limitations in Ruby</h2> <p>Ruby 2 introduced lazy evaluation to its <code>Enumarable</code> module, accessible via <code>#lazy</code>. The <span> <a href="http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-lazy">method</a> <span style="vertical-align: super"> <a href="http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-lazy" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 12 16" version="1.1" width="12" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z"/></svg></a> </span> </span> returns a new instance of a <span> <a href="http://www.ruby-doc.org/core-2.1.1/Enumerator/Lazy.html">lazy enumerator</a> <span style="vertical-align: super"> <a href="http://www.ruby-doc.org/core-2.1.1/Enumerator/Lazy.html" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 12 16" version="1.1" width="12" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z"/></svg></a> </span> </span> .</p> <p>We can use these additions to create the same sort of infinite lists that are possible in Haskell. First, we start by generating a simple infinite series, upon which we can build further abstractions.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="n">inf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="no">Float</span><span class="o">::</span><span class="no">INFINITY</span><span class="p">)</span><span class="o">.</span><span class="n">lazy</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Enumerator::Lazy: 1..Infinity&gt;</span></code></pre></figure> <p>Now we have an enumerator, upon which we can build additional abstractions. In fact, you can represent any countable set using abstractions on this enumerator.</p> <p>Unfortunately, <code>Enumerator::Lazy#zip</code> is limited, such that it is not possible to pass it a block without eager evaluation being triggered. This is easy, albeit inelegant, to circumvent by <code>#map</code>ing subsequent to a <code>#zip</code> call. For instance, to get the sum of all adjacent numbers, the following never completes.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="n">adjacents</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span></code></pre></figure> <p>But by simply interposing a <code>#map</code>, it becomes possible.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="n">adjacents</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: 1..Infinity&gt;:zip(#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: 1..Infinity&gt;:drop(1)&gt;)&gt;:map&gt;</span>

<span class="o">&gt;</span> <span class="n">adjacents</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">force</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">21</span><span class="o">]</span></code></pre></figure> <p>Note that it is necessary to force the evaluation, otherwise Ruby continues to return lazy enumerators to allow chaining.</p> <h2>Fibonacci in Lazy Ruby</h2> <p>We now have all the pieces we need to replicate the Haskell example. Ruby allows us to define a new infinite enumerator based on the original one, but lacks expressiveness for a few of the features Haskell as. As such, we need to map the infinite series onto another one using a block, which is analogous to defining a new infinite series, but does not read as cleanly.</p> <p>Regardless of how well it reads, functionally, the following example accomplishes the same as the Haskell version.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="n">fibs</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span>
      <span class="mi">1</span>
    <span class="k">else</span>
      <span class="n">fibs</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">fibs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">last</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: 1..Infinity&gt;:map&gt;</span>

<span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">force</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">55</span><span class="o">]</span></code></pre></figure> <h3>Fast &amp; Lazy Fibonacci</h3> <p>This implementation is, unsurprisingly, painfully slow since it needs to reevaluate every single preceeding term in order to calculate a given term. This is a canonical issue with the naive recursive definition of fibonacci number calculations.</p> <p>My original <span> <a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/">exposure</a> <span style="vertical-align: super"> <a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 12 16" version="1.1" width="12" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z"/></svg></a> </span> </span> to the following approach manipulates the fibonacci function by using a fixed point and a general memoization strategy based on the y combinator. For this particular example, a simple caching strategy will do, but it is worth knowing about the more general solution.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="n">fibs</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">{</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="o">[]</span>

    <span class="n">inf</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
        <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
      <span class="k">elsif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="mi">1</span>
      <span class="k">else</span>
        <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">fibs</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">fibs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span>
                        <span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span><span class="o">.</span>
                        <span class="n">first</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span>
                        <span class="n">last</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="p">}</span><span class="o">.</span><span class="n">call</span></code></pre></figure> <p>This allows us to calculate much higher values of the fibonacci sequence in a reasonable amount of time. Retrieving the 200th number happens instantly.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span></span><span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span><span class="o">.</span><span class="n">force</span><span class="o">.</span><span class="n">last</span>
<span class="o">=&gt;</span> <span class="mi">280571172992510140037611932413038677189525</span></code></pre></figure> <p>Of course, this is not particularly idiomatic Ruby, since it uses a closure to bind the cache variable. It would be possible to rewrite this as a class (and I had, admittedly, originally done so), but the resulting code is over twice as long and amounts to a great deal of boilerplate and little else.</p> <p>The way I see it, as long as we are abusing Ruby for its lazy evaluation, we may as well abuse it functionally as well.</p> <span class="post-date">05 Apr 2014</span> </div> <div class="related"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <h3> <a href="/2017/06/05/common-table-expressions-in-activerecord-a-case-study-of-quantiles/"> Common Table Expressions in ActiveRecord: A Case Study of Quantiles <small>05 Jun 2017</small> </a> </h3> </li> <li> <h3> <a href="/2017/06/18/on-maintainability-gold-plating-the-game-of-life-in-elm/"> On Maintainability: Gold Plating the Game of Life in Elm <small>18 Jun 2017</small> </a> </h3> </li> <li> <h3> <a href="/2014/05/05/writing-game-of-life-in-elm/"> Writing Game of Life in Elm <small>05 May 2014</small> </a> </h3> </li> </ul> </div> <p class="bitcoin"></p> </div> <script>!function(e,n,t,a,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=n.createElement(t),s=n.getElementsByTagName(t)[0],o.async=1,o.src=a,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-47296801-1","sonnym.github.io"),ga("send","pageview");</script> </body> </html>