<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    home &middot; effluence
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/hyde.css">
  <link rel="stylesheet" href="/css/custom.css">

  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="layout-reverse">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>effluence</h1>
      <p class="lead"></p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item active">
        <a href="/">home</a>
      </li>

      

      
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/projects/">projects</a>
            </li>
          
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">about</a>
            </li>
          
        
      

      <li class="sidebar-nav-item">
        <a href="/atom.xml" target="_blank">rss</a>
      </li>
    </ul>

    <p>&copy; 2014. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/05/05/writing-game-of-life-in-elm/">
        Writing Game of Life in Elm
      </a>
    </h1>

    <h2>Introduction</h2>

<p>In this article, we will walk through the steps for writing an implementation
of
<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" target="_blank">Conway&#39;s Game of Life</a>
in the
<a href="http://elm-lang.org/" target="_blank">Elm</a> programming language.</p>

<p>In doing so, we will learn about the basic principles involved with writing
programs in Elm, while grounding them in a concrete problem. We will be
building a single program in steps, so much of the source will be repeated
between the examples, but it will be more clear to present each step in its
entirety.</p>

<p>I first became interested in Elm after seeing Evan Czaplicki&#39;s
<a href="http://lanyrd.com/2013/mlocjs/sccwrp/" target="_blank">talk</a> from
mloc.js 2013, where he presented an overview of Elm and the compelling example
of how one would write a simple side-scroller in an extremely straight forward
fashion as a consequence of the core concept in Elm: signals.</p>

<p>Elm is a
<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">functional reactive programming</a>
language, a paradigm concerned with using an explicit model of time. Elm uses
signals as its abstraction of time-varying values, including various time
functions (e.g. <code>every second</code>), constants (e.g. <code>constant True</code>), which are
invariant over time, and user input (e.g. <code>Mouse.clicks</code>). These, and other,
signals can be combined and manipulated in various ways to achieve vastly
complex results, clearly and concisely. It is this expressive power of Elm
that I find especially interesting. The
<a href="http://elm-lang.org/learn/What-is-FRP.elm" target="_blank">overview of FRP</a>
on the Elm site is excellent resource for these core concepts.</p>

<p>For this reason, I chose Elm to explore Conway&#39;s Game of Life. Having seen that
Life can be written concisely, to an almost absurd degree, in
<a href="http://youtu.be/a9xAKttWgP4" target="_blank">APL</a>, it seems to me
to be a very interesting problem by which to compare different languages. I
have only dabbled with Elm in the past, writing a toy for
<a href="http://www.ludumdare.com/compo/ludum-dare-28/" target="_blank">LD 28</a>,
but have always wanted to spend some more time getting to know the language.</p>

<p>Without further ado, let us begin writing Conway&#39;s Game of Life.</p>

<h2>First Steps</h2>

<p>We will begin by writing a very simple static grid, the foundation for our game.
I often begin writing Elm programs with all my signals planned out, interacting
in complex ways, since that seems the more interesting part of the problem, as
compared with some boringly simple display components. The fact of the matter
is, however, that, lacking in experience with static typing and the concepts of
signals, I often find myself in a mess and have to back out.</p>

<p>I, in fact, did that with this program. Several times. I believe I come to
understand the core concepts much more, but the fact remains: start with a
solid base and build on top of it. This first example will simply a grid of a
predetermined size. It has support for cells being turned on and off, but they
are all on to begin with.</p>

<h4>static_grid.elm</h4>

<h5>Source</h5>

<div class="highlight"><pre><code class="language-elm" data-lang="elm"><span class="kn">import </span><span class="nc">List</span>

<span class="kn">import </span><span class="nc">Color</span> <span class="p">(</span><span class="nv">rgb</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">Graphics.Element</span> <span class="p">(</span><span class="kt">Element</span><span class="p">,</span> <span class="nv">flow</span><span class="p">,</span> <span class="nv">right</span><span class="p">,</span> <span class="nv">down</span><span class="p">,</span> <span class="nv">container</span><span class="p">,</span> <span class="nv">topLeft</span><span class="p">,</span> <span class="nv">spacer</span><span class="p">,</span> <span class="nv">color</span><span class="p">)</span>

<span class="nv">cellSize</span> <span class="nf">=</span> <span class="mi">5</span>
<span class="p">(</span><span class="nv">columns</span><span class="p">,</span> <span class="nv">rows</span><span class="p">)</span> <span class="nf">=</span> <span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>

<span class="kr">main </span><span class="nf">:</span> <span class="kt">Element</span>
<span class="kr">main </span><span class="nf">=</span> <span class="nv">renderGrid</span> <span class="nv">generateGrid</span>

<span class="nv">generateGrid</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">generateGrid</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">repeat</span> <span class="nv">rows</span> <span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">repeat</span> <span class="nv">columns</span> <span class="kt">True</span><span class="p">)</span>

<span class="nv">renderGrid</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">renderGrid</span> <span class="nv">grid</span> <span class="nf">=</span>
  <span class="nv">grid</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderRow</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="p">(</span><span class="nv">flow</span> <span class="nv">right</span><span class="p">)</span>
    <span class="nf">|&gt;</span> <span class="nv">flow</span> <span class="nv">down</span>
    <span class="nf">|&gt;</span> <span class="nv">container</span> <span class="p">(</span><span class="nv">cellSize</span> <span class="nf">*</span> <span class="nv">columns</span><span class="p">)</span> <span class="p">(</span><span class="nv">cellSize</span> <span class="nf">*</span> <span class="nv">rows</span><span class="p">)</span> <span class="nv">topLeft</span>

<span class="nv">renderRow</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Bool</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="kt">Element</span>
<span class="nv">renderRow</span> <span class="nv">row</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderCell</span> <span class="nv">row</span>

<span class="nv">renderCell</span> <span class="nf">:</span> <span class="kt">Bool</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">renderCell</span> <span class="nv">on</span> <span class="nf">=</span>
  <span class="nv">spacer</span> <span class="nv">cellSize</span> <span class="nv">cellSize</span>
    <span class="nf">|&gt;</span> <span class="nv">color</span> <span class="p">(</span><span class="kr">if</span> <span class="nv">on</span> <span class="kr">then</span> <span class="p">(</span><span class="nv">rgb</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="nv">rgb</span> <span class="mi">255</span> <span class="mi">255</span> <span class="mi">255</span><span class="p">))</span></code></pre></div>

<h5>Result</h5>

<iframe src="/examples/elm/static_grid.html" frameBorder="0"></iframe>

<p>The crux of this program is that we want to turn a nested list of boolean
values (<code>List (List Bool)</code>) into an <code>Element</code>, one of two possible types for
the <code>main</code> function in an Elm program. We use the <code>Element</code> API to achieve this
in a few steps.</p>

<p>This first example is, beyond those points, only really interesting
syntactically. It should feel somewhat familiar to anyone who has worked with
other functional languages. One point worth mentioning is the forward function
application helper (<code>|&gt;</code>). This helps clarify the program (at least to my eye),
when a value passes through a number of functions sequentially. The following
are equivalent: <code>(c (b a))</code> and <code>a |&gt; b |&gt; c</code>.</p>

<h2>Seeding the Grid</h2>

<p>The next step is to take the grid we created in the first example and seed it
with randomly generated examples. In Elm, the <code>Random</code> component has three
functions, all of which are a <code>Signal</code>. This means that, we can no longer be
concerned with simply taking one value and mutating it into another, but
instead, with taking a signal and converting it into another signal. The <code>main</code>
function can also be of the type <code>Signal Element</code>, which, in a sense, becomes
the goal of our program - we have an input of type <code>Signal (List Int)</code> we
will be taking from <code>Random.list</code>, and we want to convert it into a
<code>Signal Element</code> that Elm can consume.</p>

<p>Herein lies a core concept - that of <code>map</code>ing a signal. The <code>map</code> function
has the type <code>(a -&gt; b) -&gt; Signal a -&gt; Signal b</code>; it takes a function from type
<code>a</code> to type <code>b</code> and a signal of type <code>a</code> and returns a signal of type <code>b</code>. This
function is the primay means by which signals are converted from one type to
another.</p>

<p>As a consequence of the way <code>lift</code> works, by taking a function to convert a
signal, rewriting our static example to one that is randomly generated involves
very few steps. These are as follows:</p>

<ol>
<li>Change the type of <code>main</code> from <code>Element</code> to <code>Signal Element</code>.</li>
<li>Write an <code>initialSeed</code> function of type <code>Siganl Random.Seed</code></li>
<li>Write a <code>seededGrid</code> function of type <code>Random.Seed -&gt; List (List Bool)</code></li>
<li>Change <code>generateGrid</code> from <code>List (List Bool)</code> to <code>List Int -&gt; List (List Bool)</code></li>
<li><code>map</code> our <code>seededGrid</code> function through our existing <code>renderGrid</code> function.</li>
</ol>

<h4>random_grid.elm</h4>

<h5>Source</h5>

<div class="highlight"><pre><code class="language-elm" data-lang="elm"><span class="kn">import </span><span class="nc">Signal</span> <span class="p">(</span><span class="nf">(&lt;~)</span><span class="p">,</span> <span class="kt">Signal</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">Signal</span>

<span class="kn">import </span><span class="nc">List</span> <span class="p">(</span><span class="nf">(::)</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">List</span>

<span class="kn">import </span><span class="nc">Time</span>
<span class="kn">import </span><span class="nc">Random</span>

<span class="kn">import </span><span class="nc">Color</span> <span class="p">(</span><span class="nv">rgb</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">Graphics.Element</span> <span class="p">(</span><span class="kt">Element</span><span class="p">,</span> <span class="nv">flow</span><span class="p">,</span> <span class="nv">right</span><span class="p">,</span> <span class="nv">down</span><span class="p">,</span> <span class="nv">container</span><span class="p">,</span> <span class="nv">topLeft</span><span class="p">,</span> <span class="nv">spacer</span><span class="p">,</span> <span class="nv">color</span><span class="p">)</span>

<span class="nv">cellSize</span> <span class="nf">=</span> <span class="mi">5</span>
<span class="p">(</span><span class="nv">columns</span><span class="p">,</span> <span class="nv">rows</span><span class="p">)</span> <span class="nf">=</span> <span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>

<span class="kr">main </span><span class="nf">:</span> <span class="kt">Signal</span> <span class="kt">Element</span>
<span class="kr">main </span><span class="nf">=</span> <span class="nv">renderGrid</span> <span class="nf">&lt;~</span> <span class="p">(</span><span class="nv">seededGrid</span> <span class="nf">&lt;~</span> <span class="nv">initialSeed</span><span class="p">)</span>

<span class="nv">initialSeed</span> <span class="nf">:</span> <span class="kt">Signal</span> <span class="kt">Random</span><span class="nf">.</span><span class="kt">Seed</span>
<span class="nv">initialSeed</span> <span class="nf">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="nv">time</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Random</span><span class="nf">.</span><span class="nv">initialSeed</span> <span class="p">(</span><span class="nv">round</span> <span class="nv">time</span><span class="p">))</span> <span class="nf">&lt;~</span> <span class="kt">Time</span><span class="nf">.</span><span class="nv">timestamp</span> <span class="p">(</span><span class="kt">Signal</span><span class="nf">.</span><span class="nv">constant</span> <span class="p">())</span>

<span class="nv">seededGrid</span> <span class="nf">:</span> <span class="kt">Random</span><span class="nf">.</span><span class="kt">Seed</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">seededGrid</span> <span class="nv">seed</span> <span class="nf">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="nv">lst</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="nf">=</span> <span class="kt">Random</span><span class="nf">.</span><span class="nv">generate</span> <span class="p">(</span><span class="kt">Random</span><span class="nf">.</span><span class="nv">list</span> <span class="p">(</span><span class="nv">columns</span> <span class="nf">*</span> <span class="nv">rows</span><span class="p">)</span> <span class="p">(</span><span class="kt">Random</span><span class="nf">.</span><span class="nv">int</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">seed</span>
  <span class="kr">in</span> <span class="nv">generateGrid</span> <span class="nv">lst</span>

<span class="nv">generateGrid</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">generateGrid</span> <span class="nv">seeds</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">generateRow</span> <span class="p">(</span><span class="nv">groupInto</span> <span class="nv">rows</span> <span class="nv">seeds</span><span class="p">)</span>

<span class="nv">generateRow</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="kt">Bool</span>
<span class="nv">generateRow</span> <span class="nv">seeds</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="p">(</span><span class="nf">\</span><span class="nv">n</span> <span class="nf">-&gt;</span> <span class="nv">n</span> <span class="nf">==</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">seeds</span>

<span class="nv">renderGrid</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">renderGrid</span> <span class="nv">grid</span> <span class="nf">=</span>
  <span class="nv">grid</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderRow</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="p">(</span><span class="nv">flow</span> <span class="nv">right</span><span class="p">)</span>
    <span class="nf">|&gt;</span> <span class="nv">flow</span> <span class="nv">down</span>
    <span class="nf">|&gt;</span> <span class="nv">container</span> <span class="p">(</span><span class="nv">cellSize</span> <span class="nf">*</span> <span class="nv">columns</span><span class="p">)</span> <span class="p">(</span><span class="nv">cellSize</span> <span class="nf">*</span> <span class="nv">rows</span><span class="p">)</span> <span class="nv">topLeft</span>

<span class="nv">renderRow</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Bool</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="kt">Element</span>
<span class="nv">renderRow</span> <span class="nv">row</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderCell</span> <span class="nv">row</span>

<span class="nv">renderCell</span> <span class="nf">:</span> <span class="kt">Bool</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">renderCell</span> <span class="nv">on</span> <span class="nf">=</span>
  <span class="nv">spacer</span> <span class="nv">cellSize</span> <span class="nv">cellSize</span>
    <span class="nf">|&gt;</span> <span class="nv">color</span> <span class="p">(</span><span class="kr">if</span> <span class="nv">on</span> <span class="kr">then</span> <span class="p">(</span><span class="nv">rgb</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="nv">rgb</span> <span class="mi">255</span> <span class="mi">255</span> <span class="mi">255</span><span class="p">))</span>

<span class="nv">groupInto</span> <span class="nf">:</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="nv">a</span><span class="p">)</span>
<span class="nv">groupInto</span> <span class="nv">groups</span> <span class="nv">initial</span> <span class="nf">=</span>
  <span class="kr">let</span>
    <span class="nv">len</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">length</span> <span class="nv">initial</span>
    <span class="nv">n</span> <span class="nf">=</span> <span class="nv">len</span> <span class="nf">//</span> <span class="nv">groups</span>
  <span class="kr">in</span>
    <span class="kt">List</span><span class="nf">.</span><span class="nv">repeat</span> <span class="nv">groups</span> <span class="p">[]</span>
      <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">indexedMap</span> <span class="p">(</span><span class="nf">\</span><span class="nv">i</span> <span class="nv">_</span> <span class="nf">-&gt;</span>
          <span class="kt">List</span><span class="nf">.</span><span class="nv">take</span> <span class="nv">n</span> <span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">drop</span> <span class="p">(</span><span class="nv">n</span> <span class="nf">*</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">initial</span><span class="p">))</span></code></pre></div>

<h5>Result</h5>

<iframe src="/examples/elm/random_grid.html" frameBorder="0"></iframe>

<p>We do write two other helper functions, <code>generateRow</code> and <code>groupInto</code>, but
neither change is essential for the example. In fact, the rendering we wrote
before, the helpers, and now the basic seeding never needs to change again.</p>

<p>These core input and output signals will remain constant, but we will have to
add some additional transitions in order to make life evolve.</p>

<h2>Adding Generations</h2>

<p>This final piece of the puzzle is to make the grid evolve from one generation
to the next. Elm makes this exceptionally easy with its concept of past
dependent signals. The function <code>foldp</code>, of type
<code>(a -&gt; b -&gt; b) -&gt; b -&gt; Signal a -&gt; Signal b</code> takes a function of two values,
a default value for the output signal, and an input signal. The function takes
two arguments: the current value of the input signal, and the past value (or
the default on the first event).</p>

<p>We can use this construct to take our <code>initialSeed</code> of <code>Signal (List (List Bool))</code>
and step it from generation to generation. This is, again, a comparatively simple
process, consisting primarily of the following steps:</p>

<ol>
<li>Update the main function to make use of <code>foldp</code>.</li>
<li>Create a <code>step</code> function of type <code>List (List Bool) -&gt; List (List Bool) -&gt; List (List Bool)</code>.</li>
<li>Create an <code>evolve</code> function of type <code>List (List Bool) -&gt; List (List Bool)</code>.</li>
</ol>

<h4>game_of_life.elm</h4>

<h5>Source</h5>

<div class="highlight"><pre><code class="language-elm" data-lang="elm"><span class="kn">import </span><span class="nc">Signal</span> <span class="p">(</span><span class="nf">(&lt;~)</span><span class="p">,</span> <span class="kt">Signal</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">Signal</span>

<span class="kn">import </span><span class="nc">List</span> <span class="p">(</span><span class="nf">(::)</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">List</span>

<span class="kn">import </span><span class="nc">Time</span>
<span class="kn">import </span><span class="nc">Random</span>

<span class="kn">import </span><span class="nc">Color</span> <span class="p">(</span><span class="nv">rgb</span><span class="p">)</span>
<span class="kn">import </span><span class="nc">Graphics.Element</span> <span class="p">(</span><span class="kt">Element</span><span class="p">,</span> <span class="nv">flow</span><span class="p">,</span> <span class="nv">right</span><span class="p">,</span> <span class="nv">down</span><span class="p">,</span> <span class="nv">container</span><span class="p">,</span> <span class="nv">topLeft</span><span class="p">,</span> <span class="nv">spacer</span><span class="p">,</span> <span class="nv">color</span><span class="p">)</span>

<span class="nv">cellSize</span> <span class="nf">=</span> <span class="mi">5</span>
<span class="p">(</span><span class="nv">columns</span><span class="p">,</span> <span class="nv">rows</span><span class="p">)</span> <span class="nf">=</span> <span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>

<span class="kr">main </span><span class="nf">:</span> <span class="kt">Signal</span> <span class="kt">Element</span>
<span class="kr">main </span><span class="nf">=</span>
  <span class="kt">Signal</span><span class="nf">.</span><span class="nv">sampleOn</span> <span class="p">(</span><span class="kt">Time</span><span class="nf">.</span><span class="nv">every</span> <span class="kt">Time</span><span class="nf">.</span><span class="nv">second</span><span class="p">)</span> <span class="p">(</span><span class="nv">seededGrid</span> <span class="nf">&lt;~</span> <span class="nv">initialSeed</span><span class="p">)</span>
    <span class="nf">|&gt;</span> <span class="kt">Signal</span><span class="nf">.</span><span class="nv">foldp</span> <span class="p">(</span><span class="nv">step</span><span class="p">)</span> <span class="p">[[]]</span>
    <span class="nf">|&gt;</span> <span class="kt">Signal</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderGrid</span>

<span class="nv">step</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">step</span> <span class="nv">current</span> <span class="nv">past</span> <span class="nf">=</span> <span class="kr">if</span> <span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">isEmpty</span> <span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">head</span> <span class="nv">past</span><span class="p">))</span> <span class="kr">then</span> <span class="nv">current</span> <span class="kr">else</span> <span class="p">(</span><span class="nv">evolve</span> <span class="nv">past</span><span class="p">)</span>

<span class="nv">initialSeed</span> <span class="nf">:</span> <span class="kt">Signal</span> <span class="kt">Random</span><span class="nf">.</span><span class="kt">Seed</span>
<span class="nv">initialSeed</span> <span class="nf">=</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="nv">time</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Random</span><span class="nf">.</span><span class="nv">initialSeed</span> <span class="p">(</span><span class="nv">round</span> <span class="nv">time</span><span class="p">))</span> <span class="nf">&lt;~</span> <span class="kt">Time</span><span class="nf">.</span><span class="nv">timestamp</span> <span class="p">(</span><span class="kt">Signal</span><span class="nf">.</span><span class="nv">constant</span> <span class="p">())</span>

<span class="nv">seededGrid</span> <span class="nf">:</span> <span class="kt">Random</span><span class="nf">.</span><span class="kt">Seed</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">seededGrid</span> <span class="nv">seed</span> <span class="nf">=</span>
  <span class="kr">let</span> <span class="p">(</span><span class="nv">lst</span><span class="p">,</span> <span class="nv">_</span><span class="p">)</span> <span class="nf">=</span> <span class="kt">Random</span><span class="nf">.</span><span class="nv">generate</span> <span class="p">(</span><span class="kt">Random</span><span class="nf">.</span><span class="nv">list</span> <span class="p">(</span><span class="nv">columns</span> <span class="nf">*</span> <span class="nv">rows</span><span class="p">)</span> <span class="p">(</span><span class="kt">Random</span><span class="nf">.</span><span class="nv">int</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">seed</span>
  <span class="kr">in</span> <span class="nv">generateGrid</span> <span class="nv">lst</span>

<span class="nv">generateGrid</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">generateGrid</span> <span class="nv">seeds</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">generateRow</span> <span class="p">(</span><span class="nv">groupInto</span> <span class="nv">rows</span> <span class="nv">seeds</span><span class="p">)</span>

<span class="nv">generateRow</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="kt">Bool</span>
<span class="nv">generateRow</span> <span class="nv">seeds</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="p">(</span><span class="nf">\</span><span class="nv">n</span> <span class="nf">-&gt;</span> <span class="nv">n</span> <span class="nf">==</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">seeds</span>

<span class="nv">evolve</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nv">evolve</span> <span class="nv">generation</span> <span class="nf">=</span>
  <span class="kt">List</span><span class="nf">.</span><span class="nv">indexedMap</span> <span class="p">(</span><span class="nf">\</span><span class="nv">y</span> <span class="nv">row</span> <span class="nf">-&gt;</span>
    <span class="kt">List</span><span class="nf">.</span><span class="nv">indexedMap</span> <span class="p">(</span><span class="nf">\</span><span class="nv">x</span> <span class="nv">_</span> <span class="nf">-&gt;</span>
      <span class="nv">descend</span> <span class="nv">generation</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">row</span><span class="p">)</span> <span class="nv">generation</span>

<span class="nv">descend</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">Bool</span>
<span class="nv">descend</span> <span class="nv">grid</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nf">=</span>
  <span class="kt">List</span><span class="nf">.</span><span class="nv">concatMap</span> <span class="p">(</span><span class="nf">\</span><span class="nv">n</span> <span class="nf">-&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="p">(</span><span class="nf">\</span><span class="nv">m</span> <span class="nf">-&gt;</span> <span class="p">(</span><span class="nv">x</span> <span class="nf">+</span> <span class="nv">n</span><span class="p">,</span> <span class="nv">y</span> <span class="nf">+</span> <span class="nv">m</span><span class="p">))</span>
                   <span class="p">[</span><span class="nf">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="p">[</span><span class="nf">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">filter</span> <span class="p">(</span><span class="nf">\</span><span class="nv">p</span> <span class="nf">-&gt;</span> <span class="p">(</span><span class="nv">fst</span> <span class="nv">p</span><span class="p">)</span> <span class="nf">&gt;</span> <span class="nf">-</span><span class="mi">1</span> <span class="nf">&amp;&amp;</span> <span class="p">(</span><span class="nv">fst</span> <span class="nv">p</span><span class="p">)</span> <span class="nf">&lt;</span> <span class="nv">columns</span> <span class="nf">&amp;&amp;</span>
                          <span class="p">(</span><span class="nv">snd</span> <span class="nv">p</span><span class="p">)</span> <span class="nf">&gt;</span> <span class="nf">-</span><span class="mi">1</span> <span class="nf">&amp;&amp;</span> <span class="p">(</span><span class="nv">snd</span> <span class="nv">p</span><span class="p">)</span> <span class="nf">&lt;</span> <span class="nv">rows</span> <span class="nf">&amp;&amp;</span>
                          <span class="p">(</span><span class="nv">not</span> <span class="p">((</span><span class="nv">fst</span> <span class="nv">p</span><span class="p">)</span> <span class="nf">==</span> <span class="nv">x</span> <span class="nf">&amp;&amp;</span> <span class="p">(</span><span class="nv">snd</span> <span class="nv">p</span><span class="p">)</span> <span class="nf">==</span> <span class="nv">y</span><span class="p">)))</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">filter</span> <span class="p">(</span><span class="nf">\</span><span class="nv">p</span> <span class="nf">-&gt;</span> <span class="p">(</span><span class="nv">itemAt</span> <span class="p">(</span><span class="nv">fst</span> <span class="nv">p</span><span class="p">)</span>
                            <span class="p">(</span><span class="nv">itemAt</span> <span class="p">(</span><span class="nv">snd</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">grid</span><span class="p">))</span> <span class="nf">==</span> <span class="kt">True</span><span class="p">)</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">length</span>
    <span class="nf">|&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="nv">l</span> <span class="nf">-&gt;</span> <span class="p">((</span><span class="nv">itemAt</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">itemAt</span> <span class="nv">y</span> <span class="nv">grid</span><span class="p">))</span>
                <span class="nf">&amp;&amp;</span> <span class="nv">l</span> <span class="nf">&gt;</span> <span class="mi">1</span> <span class="nf">&amp;&amp;</span> <span class="nv">l</span> <span class="nf">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="nf">||</span> <span class="nv">l</span> <span class="nf">==</span> <span class="mi">3</span><span class="p">)</span>

<span class="nv">renderGrid</span> <span class="nf">:</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">Bool</span><span class="p">)</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">renderGrid</span> <span class="nv">grid</span> <span class="nf">=</span>
  <span class="nv">grid</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderRow</span>
    <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="p">(</span><span class="nv">flow</span> <span class="nv">right</span><span class="p">)</span>
    <span class="nf">|&gt;</span> <span class="nv">flow</span> <span class="nv">down</span>
    <span class="nf">|&gt;</span> <span class="nv">container</span> <span class="p">(</span><span class="nv">cellSize</span> <span class="nf">*</span> <span class="nv">columns</span><span class="p">)</span> <span class="p">(</span><span class="nv">cellSize</span> <span class="nf">*</span> <span class="nv">rows</span><span class="p">)</span> <span class="nv">topLeft</span>

<span class="nv">renderRow</span> <span class="nf">:</span> <span class="kt">List</span> <span class="kt">Bool</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="kt">Element</span>
<span class="nv">renderRow</span> <span class="nv">row</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">map</span> <span class="nv">renderCell</span> <span class="nv">row</span>

<span class="nv">renderCell</span> <span class="nf">:</span> <span class="kt">Bool</span> <span class="nf">-&gt;</span> <span class="kt">Element</span>
<span class="nv">renderCell</span> <span class="nv">on</span> <span class="nf">=</span>
  <span class="nv">spacer</span> <span class="nv">cellSize</span> <span class="nv">cellSize</span>
    <span class="nf">|&gt;</span> <span class="nv">color</span> <span class="p">(</span><span class="kr">if</span> <span class="nv">on</span> <span class="kr">then</span> <span class="p">(</span><span class="nv">rgb</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">else</span> <span class="p">(</span><span class="nv">rgb</span> <span class="mi">255</span> <span class="mi">255</span> <span class="mi">255</span><span class="p">))</span>

<span class="nv">itemAt</span> <span class="nf">:</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="nv">a</span>
<span class="nv">itemAt</span> <span class="nv">i</span> <span class="nv">lst</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">head</span> <span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">drop</span> <span class="nv">i</span> <span class="nv">lst</span><span class="p">)</span>

<span class="nv">groupInto</span> <span class="nf">:</span> <span class="kt">Int</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="nv">a</span> <span class="nf">-&gt;</span> <span class="kt">List</span> <span class="p">(</span><span class="kt">List</span> <span class="nv">a</span><span class="p">)</span>
<span class="nv">groupInto</span> <span class="nv">groups</span> <span class="nv">initial</span> <span class="nf">=</span>
  <span class="kr">let</span>
    <span class="nv">len</span> <span class="nf">=</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">length</span> <span class="nv">initial</span>
    <span class="nv">n</span> <span class="nf">=</span> <span class="nv">len</span> <span class="nf">//</span> <span class="nv">groups</span>
  <span class="kr">in</span>
    <span class="kt">List</span><span class="nf">.</span><span class="nv">repeat</span> <span class="nv">groups</span> <span class="p">[]</span>
      <span class="nf">|&gt;</span> <span class="kt">List</span><span class="nf">.</span><span class="nv">indexedMap</span> <span class="p">(</span><span class="nf">\</span><span class="nv">i</span> <span class="nv">_</span> <span class="nf">-&gt;</span>
          <span class="kt">List</span><span class="nf">.</span><span class="nv">take</span> <span class="nv">n</span> <span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">drop</span> <span class="p">(</span><span class="nv">n</span> <span class="nf">*</span> <span class="nv">i</span><span class="p">)</span> <span class="nv">initial</span><span class="p">))</span></code></pre></div>

<h5>Result</h5>

<iframe src="/examples/elm/game_of_life.html" frameBorder="0"></iframe>

<p>The only real nuance here is that we must <code>sampleOn seed (every second)</code>, which
updates the signal with the constant initial value. We use an empty default to
determine whether we should return the value from the seed, or whether we should
evlove the past value.</p>

<p>We use an <code>indexedMap</code> for the <code>evolve</code> function, because we will need to
have the index of the cell available when calling the <code>descend</code> function. Aside
from these points, it is simply gathering all the neighboring cells, filtering
invalid ones, counting live neighbors, and mapping to a new boolean value.</p>

<h2>Conclusion and Futher Steps</h2>

<p>Elm is a wonderful and extremely expressive language, and my experiences with it
have been overwhelmingly positive. I think it is excellent for these types of
applications, and its core concepts are very solid. While neophytes may
struggle with the type system - I know I have had my share of problems - this
can be solved through experience. The community, moreover, is both
knowledgeable and willing to help. When I had a question, Evan responded almost
immediately and Jeff Smits elucidated my misconceptions.</p>

<p>In terms of this example, I think it is clear so long as the core concepts are
in place. It may be longer than the APL example, but I did also err on the side
of clarity over brevity. I have a feeling this could be condensed considerably
were that the goal of the exercise.</p>

<p>As such, the most interesting way to proceed with this start would be to add
interactive elements. Allowing a user to control things like cell size and
count, duration of a generation, to flip individuals cells, to pause the game.
The list could probaby go on and on, and combining signals from many different
inputs is one of the strengths of Elm. I intend on revisiting this example and
improving upon it in the near future, so wach out for that update.</p>

<p>(This post was updated for Elm 0.14 on 13 Dec 2014)</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/04/05/lazy-ruby/">
        Lazy Ruby
      </a>
    </h1>

    <h2>Lazy Evaluation and Recursive Lists</h2>

<p>In Haskell, it is possible to construct infinite lists via recursive
definition. This is only possible because Haskell uses
<a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank">lazy evaluation</a>
rather than eager evaluation. Otherwise, the entire list would need to be
calculated and the program would never terminate.</p>

<p>Because Haskell makes it easy to define lists and is lazy, the code for
defining an infinite series is very simple. The following list represents
the fibonacci sequence.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">1</span> <span class="kt">:</span> <span class="mi">1</span> <span class="kt">:</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span></code></pre></div>

<p>The list is defined recursively; the first two values are one, and every
subsequent value is the sum of zipping the entire list with the tail of the
list, evaluating to the sum of the two previous number for any position beyond
the second. Pulling numbers off the list is as easy as the following.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="n">fibs</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">34</span><span class="p">,</span><span class="mi">55</span><span class="p">]</span></code></pre></div>

<p>I was originally exposed to this concept while reading the book
<a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/">Programming Languages: Application and Interpretation</a>
which provides a more thorough introduction to the topic of lazy evaluation.</p>

<h2>Spurious Examples and Limitations in Ruby</h2>

<p>Ruby 2 introduced lazy evaluation to its <code>Enumarable</code> module, accessible via
<code>#lazy</code>. The
<a href="http://www.ruby-doc.org/core-2.1.1/Enumerable.html#method-i-lazy" target="_blank">method</a>
returns a new instance of a
<a href="http://www.ruby-doc.org/core-2.1.1/Enumerator/Lazy.html" target="_blank">lazy enumerator</a>.</p>

<p>We can use these additions to create the same sort of infinite lists that are
possible in Haskell. First, we start by generating a simple infinite series,
upon which we can build further abstractions.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="n">inf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="no">Float</span><span class="o">::</span><span class="no">INFINITY</span><span class="p">)</span><span class="o">.</span><span class="n">lazy</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Enumerator::Lazy: 1..Infinity&gt;</span></code></pre></div>

<p>Now we have an enumerator, upon which we can build additional abstractions. In
fact, you can represent any countable set using abstractions on this
enumerator.</p>

<p>Unfortunately, <code>Enumerator::Lazy#zip</code> is limited, such that it is not possible
to pass it a block without eager evaluation being triggered. This is easy,
albeit inelegent, to circumvent by <code>#map</code>ing subsequent to a <code>#zip</code> call. For
instance, to get the sum of all adjacent numbers, the following never
completes.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="n">adjacents</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span></code></pre></div>

<p>But by simply interposing a <code>#map</code>, it becomes possible.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="n">adjacents</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">inf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: 1..Infinity&gt;:zip(#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: 1..Infinity&gt;:drop(1)&gt;)&gt;:map&gt;</span>

<span class="o">&gt;</span> <span class="n">adjacents</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">force</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">21</span><span class="o">]</span></code></pre></div>

<p>Note that it is necessary to forece the evaluation, otherwise Ruby continues to
return lazy enumerators to allow chaining.</p>

<h2>Fibonacci in Lazy Ruby</h2>

<p>We now have all the pieces we need to replicate the Haskell example. Ruby
allows us to define a new infinite enumerator based on the original one, but
lacks expressiveness for a few of the features Haskell as. As such, we need to
map the infinite series onto another one using a block, which is analogous to
defining a new infinite series, but does not read as cleanly.</p>

<p>Regardless of how well it reads, functionally, the following example
accomplishes the same as the Haskell version.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="n">fibs</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span>
      <span class="mi">1</span>
    <span class="k">else</span>
      <span class="n">fibs</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">fibs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">last</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: 1..Infinity&gt;:map&gt;</span>

<span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">force</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">55</span><span class="o">]</span></code></pre></div>

<h3>Fast &amp; Lazy Fibonacci</h3>

<p>This implementation is, unsurprisingly, painfully slow since it needs to
reevaluate every single preceeding term in order to calculate a given term.
This is a canonical issue with the naive recursive definition of fibonacci
number calculations.</p>

<p>My original
<a href="http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/" target="_blank">exposure</a>
to the following approach manipulates the fibonacci function by using a fixed
point and a general memoization strategy based on the y combinator. For this
particular example, a simple caching strategy will do, but it is worth knowing
about the more general solution.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="n">fibs</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">{</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="o">[]</span>

    <span class="n">inf</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
        <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span>
      <span class="k">elsif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span>
        <span class="mi">1</span>
      <span class="k">else</span>
        <span class="n">cache</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="n">fibs</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">fibs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span>
                        <span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span><span class="o">.</span>
                        <span class="n">first</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span>
                        <span class="n">last</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="p">}</span><span class="o">.</span><span class="n">call</span></code></pre></div>

<p>This allows us to calculate much higher values of the fibonacci sequence in a
reasonable amount of time. Retrieving the 200th number happens instantly.</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span><span class="o">.</span><span class="n">force</span><span class="o">.</span><span class="n">last</span>
<span class="o">=&gt;</span> <span class="mi">280571172992510140037611932413038677189525</span></code></pre></div>

<p>Of course, this is not particularly idiomatic Ruby, since it uses a closure to
bind the cache variable. It would be possible to rewrite this as a class (and
I had, admittedly, originally done so), but the resulting code is over twice as
long and amounts to a great deal of boilerplate and little else.</p>

<p>The way I see it, as long as we are abusing Ruby for its lazy evaluation, we
may as well abuse it functionally as well.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/02/05/hooks-in-angularjs-controllers/">
        Hooks in AngularJS Controllers
      </a>
    </h1>

    <h2>The Situation</h2>

<p>Sometimes when working with nested scopes, you may encounter a situation in
which some scope action depends on the status of some arbitarily nested
controller. This could be a multi-part form built from reusable components,
preventing the user from proceeding until complete, for example.</p>

<p>An architecture that allows scopes nested within another scope to influence the
life cycle of the latter has one primary advantage, namely, greater separation
of concerns. A nested controller can supply functions for data validation and
formatting, while the parent controller defines functions for navigation and
accumulation of results. This leads to better modularity, as the parent
controller is isolated from the implementation of nested controllers, while the
latter are able to be used modularly in more contexts.</p>

<h2>A Simple Example</h2>

<p><a href="http://plnkr.co/edit/QKzZZq?p=preview" target="_blank">Open in Plunkr</a></p>

<p>As the structure of the following example indicates, we have three controllers
- one that coordinates and two that handle user input. We have taken the
liberty of using
<a href="http://underscorejs.org/" target="_blank">underscore</a>
to simplify checking if all conditions are met.</p>

<p>Here, the <code>FormCheckboxCtrl</code> has no validation, but does coerce its results to
be human readible, while <code>FormTextInputCtrl</code> returns the text input and is
invalid if none is provided.</p>

<p>What remains is, simply, to make it work.</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;body</span> <span class="na">ng-app=</span><span class="s">&quot;HookExample&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">ng-controller=</span><span class="s">&quot;FormPageCtrl&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;p&gt;</span>Please enter some text below.<span class="nt">&lt;/p&gt;</span>

    <span class="nt">&lt;span</span> <span class="na">ng-controller=</span><span class="s">&quot;FormCheckboxCtrl&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;checkbox&quot;</span> <span class="na">ng-model=</span><span class="s">&quot;checkbox&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/span&gt;</span>

    <span class="nt">&lt;span</span> <span class="na">ng-controller=</span><span class="s">&quot;FormTextInputCtrl&quot;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;text&quot;</span> <span class="na">ng-model=</span><span class="s">&quot;textInput&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/span&gt;</span>

    <span class="nt">&lt;div</span> <span class="na">ng-show=</span><span class="s">&quot;showResults()&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/body&gt;</span></code></pre></div>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">HookExample</span> <span class="o">=</span> <span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s2">&quot;HookExample&quot;</span><span class="p">,</span> <span class="p">[]);</span>

<span class="nx">HookExample</span><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s2">&quot;FormPageCtrl&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">,</span> <span class="nx">RegisterHook</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">$scope</span><span class="p">.</span><span class="nx">showResults</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">RegisterHook</span><span class="p">(</span><span class="s2">&quot;isDataValid&quot;</span><span class="p">,</span> <span class="nx">$scope</span><span class="p">,</span> <span class="nx">_</span><span class="p">.</span><span class="nx">every</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nx">$scope</span><span class="p">.</span><span class="nx">results</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">RegisterHook</span><span class="p">(</span><span class="s2">&quot;getResults&quot;</span><span class="p">,</span> <span class="nx">$scope</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">results</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">results</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot; - &quot;</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">};</span>
<span class="p">});</span>

<span class="nx">HookExample</span><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s2">&quot;FormTextInputCtrl&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">$scope</span><span class="p">.</span><span class="nx">isDataValid</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">$scope</span><span class="p">.</span><span class="nx">textInput</span> <span class="o">&amp;&amp;</span> <span class="nx">$scope</span><span class="p">.</span><span class="nx">textInput</span> <span class="o">!==</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nx">$scope</span><span class="p">.</span><span class="nx">getResults</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">$scope</span><span class="p">.</span><span class="nx">textInput</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">});</span>

<span class="nx">HookExample</span><span class="p">.</span><span class="nx">controller</span><span class="p">(</span><span class="s2">&quot;FormCheckboxCtrl&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">$scope</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">$scope</span><span class="p">.</span><span class="nx">getResults</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">$scope</span><span class="p">.</span><span class="nx">checkbox</span> <span class="o">?</span> <span class="s2">&quot;Yes&quot;</span> <span class="o">:</span> <span class="s2">&quot;No&quot;</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">});</span></code></pre></div>

<h2>A Hook Implementation</h2>

<p>By recursively traversing the <code>$$childHead</code> and <code>$$nextSibling</code> properties of
the scope, we can give ask if any controller nested within the heirarchy wishes
to respond to the hook, thereby influincing the life cycle of our parent
controller.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">HookExample</span><span class="p">.</span><span class="nx">factory</span><span class="p">(</span><span class="s2">&quot;RegisterHook&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="p">(</span><span class="kd">function</span> <span class="nx">traverse</span><span class="p">(</span><span class="nx">scope</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">scope</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="nx">_</span><span class="p">.(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">scope</span><span class="p">[</span><span class="nx">name</span><span class="p">]());</span>
      <span class="p">}</span>

      <span class="nx">traverse</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">$$childHead</span><span class="p">);</span>
      <span class="nx">traverse</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">$$nextSibling</span><span class="p">);</span>
    <span class="p">})(</span><span class="nx">scope</span><span class="p">.</span><span class="nx">$$childHead</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span></code></pre></div>

<p>This simple implemnation will look for and call the <code>name</code> function on any
scope, starting from the <code>$$childHead</code> of the scope passed in. Once all the
results have been accumulated, the <code>callback</code> is called with those results,
allowing for a nice functional interface, as in the case of passing in
<code>_.every</code>.</p>

<p>Since the callback is required in this naive implementation, it
would be possible to pass in <code>angular.noop</code> as the callback to discard the
results, thereby issuing some call to arbitrarily nested controllers. In that
case, however, a more reasonable approach would be to <code>$broadcast</code> an event.</p>

<h2>Hooks vs. Events vs. Services</h2>

<p>When is this approach of registering hooks more appropriate than using events?
Primarily when you need to get the data back from the user via collaborating
controllers. The way event broadcasting requires an event to the child
controllers, each of which must call another event for the parent controller to
handle quickly becomes brittle.  In cases where the data is not transient, it
is likely best to use a service object to store all the data and have the
collaborators reference it directly.</p>

<p>That said, there is certainly still a place for hooks like the one outlined
above, but it is necessary to use it in appropriate situations. Littering our
code with hooks that would be best treated as services for their persistence or
events for their unidirectionality will not be an improvement.</p>

<p>But in cases where data transience and bidirectional collaboration between
controllers at different levels of nesting is present, hooks reign supreme by
exposing carefully selected points of interaction.</p>

<h2>Improvements</h2>

<p>Herein, we have only examined a very simple hooking mechanism, which can
certainly be built out to have some additional interesting properties. Optional
callbacks and the ability to handle arguments would be straight forward
changes.  More interesting is the possiblity to return more than just a single
function for accumulating results, but instead having a more robust interface.
This could include functionality akin to that in <code>ActiveRecord</code> callbacks,
wherein returning false prevents future hooks from running and prevents some
default action.</p>

  </div>
  
</div>

<div class="pagination">
  
    <span class="pagination-item older">Older</span>
  

  
    <span class="pagination-item newer">Newer</span>
  
</div>

    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-47296801-1', 'sonnym.github.io');
      ga('send', 'pageview');
    </script>

  </body>
</html>
