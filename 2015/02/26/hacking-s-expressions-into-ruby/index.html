<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"> <head> <script async src="https://www.googletagmanager.com/gtag/js?id=G-3N6CESJ0B5"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-3N6CESJ0B5");</script> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"> <link rel="manifest" href="/site.webmanifest"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Hacking S-expressions into Ruby &middot; effluence </title> <link rel="stylesheet" href="/assets/css/styles.css"> <link rel="preconnect" href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Epilogue&display=swap" rel="stylesheet"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <link rel="canonical" href="https://sonnym.com/2015/02/26/hacking-s-expressions-into-ruby/"> </head> <body class="layout-reverse"> <div class="sidebar"> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1>effluence</h1> <p class="lead"></p> </div> <ul class="sidebar-nav"> <li class="sidebar-nav-item"> <a href="/">home</a> </li> <li class="sidebar-nav-item"> <a href="/about/">about</a> </li> <li class="sidebar-nav-item"> <a href="/atom.xml" target="_blank">rss</a> </li> </ul> <p>&copy; 2026. All rights reserved.</p> </div> </div> <div class="content container"> <div class="post"> <h1 class="post-title">Hacking S-expressions into Ruby</h1> <h2 id="background">Background</h2> <p><span class="fancylink"> <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a> <span> <a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> are a classic means of storing trees of data. Part of the original Lisp specification, they have been a part of software engineering since the very beginning. Other languages, notably Scheme and, more recently, Clojure, have helped maintain the relevancy of this very simple means for representing data.</p> <p>In the spirit of <span class="fancylink"> <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">Greenspun’s tenth rule</a> <span> <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>, we are going to attempt make first-class s-expressions in Ruby. There is already a <span class="fancylink"> <a href="http://rosettacode.org/wiki/S-Expressions#Ruby">nice implementation</a> <span> <a href="http://rosettacode.org/wiki/S-Expressions#Ruby" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> of s-expressions in Ruby, for reference, but they are not first-class, which makes them less than ideal. As such, we are going to to see how far we can push (read: abuse) the dynamic nature of the Ruby language, and investigate just how much control we have over certain elements of its syntax.</p> <p>For anyone more interested in the result than the journey, be warned that this attempt will not be successful, but some interesting results will be found along the road to ultimate failure.</p> <h2 id="a-simple-hack">A Simple Hack</h2> <p>The most natural way for storing nested lists of data in Ruby, is its <code class="language-plaintext highlighter-rouge">Array</code> class. We will be able to skip most of the important details, and simply need to write a mechanism for calling an Array.</p> <p>The following is a fairly trivial <span class="fancylink"> <a href="https://en.wikipedia.org/wiki/Monkey-patch">duck punch</a> <span> <a href="https://en.wikipedia.org/wiki/Monkey-patch" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> on the <code class="language-plaintext highlighter-rouge">Array</code> class that introduces a new <code class="language-plaintext highlighter-rouge">Array#call</code> method. This method treats the first item in the array as an operation to be performed, and the second as the implicit receiver of that message. If the receiver responds to the message, that method is called, with the rest of the original array as arguments; if not, then the operation is called directly with the entire remainder of the array as arguments.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Array</span>
  <span class="k">def</span> <span class="nf">call</span>
    <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">empty?</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">first</span>
    <span class="n">receiver</span> <span class="o">=</span> <span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">first</span>

    <span class="k">if</span> <span class="n">receiver</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
      <span class="n">receiver</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">drop</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span>
      <span class="nb">send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">drop</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure> <p>This is a terribly incomplete implementation, and we cannot recommend it for production software. Were it more correct, it would still not be advisable to use for any realistic purposes. In spite of that realistic perspective, this actually produces some decent results.</p> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[].</span><span class="nf">call</span>
<span class="p">=&gt;</span> <span class="p">[]</span>

<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">].</span><span class="nf">call</span>
<span class="go">foo
</span><span class="p">=&gt;</span> <span class="kp">nil</span>

<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[:</span><span class="o">+</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="nf">call</span>
<span class="p">=&gt;</span> <span class="mi">3</span>

<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="p">[</span><span class="ss">:class</span><span class="p">,</span> <span class="p">[]].</span><span class="nf">call</span><span class="p">].</span><span class="nf">call</span>
<span class="p">=&gt;</span> <span class="no">Array</span></code></pre></figure> <p>Being required to <code class="language-plaintext highlighter-rouge">call</code> each array after instantiation, however, is incredibly suboptimal—from a standpoint of maintainability and legibility, of course. Perhaps it will be possible for us to be able to have this method get called automatically under some circumstances. In order to do this, we will need to investigate how arrays get instantiated and see if we can hook into that process to streamline our s-expressions.</p> <h2 id="array-literals-in-ruby">Array Literals in Ruby</h2> <p>The first thing to try is overriding <code class="language-plaintext highlighter-rouge">Array#initialize</code>, which should be a simple enough way to transform arrays into s-expressions (read: completely break the functionality thereof). For this first pass, we will just add some debugging output to verify that this is the correct place to hook in and abuse Ruby.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Array</span>
  <span class="k">alias</span> <span class="n">orig_initialize</span> <span class="n">initialize</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"This is where we break things"</span>
    <span class="n">orig_initialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="p">=&gt;</span> <span class="p">[]</span></code></pre></figure> <p>For some reason, the constructor function never gets called when using the array literal syntax. Luckily, we can also manipulate the <code class="language-plaintext highlighter-rouge">Array::new</code> method, so surely that must be the answer. Tapping into individual methods to check if they are getting called will quickly become tedious, however, so first we should factor out that process into a function.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">observe_method</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>
  <span class="n">object</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:alias_method</span><span class="p">,</span> <span class="s2">"orig_</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>

  <span class="n">object</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
    <span class="nb">name</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="n">object</span><span class="si">}</span><span class="s2">#</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span>

    <span class="nb">puts</span>  <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> args: "</span><span class="c1">#{args.inspect}"</span>

    <span class="nb">send</span><span class="p">(</span><span class="s2">"orig_</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">).</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">return_value</span><span class="o">|</span>
      <span class="nb">puts</span> <span class="s2">"return value is: </span><span class="si">#{</span><span class="n">return_value</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">observe_method</span><span class="p">(</span><span class="no">Array</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">,</span> <span class="ss">:new</span><span class="p">)</span></code></pre></figure> <p>Now, looking into the call to <code class="language-plaintext highlighter-rouge">Array::new</code>, we should expect to see some debugging output.</p> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="p">=&gt;</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="sx">%w()</span>
<span class="p">=&gt;</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="sx">%i()</span>
<span class="p">=&gt;</span> <span class="p">[]</span></code></pre></figure> <p>Surely, <code class="language-plaintext highlighter-rouge">Kernel.Array</code>, <code class="language-plaintext highlighter-rouge">Array::[]</code>, <code class="language-plaintext highlighter-rouge">Array.to_a</code>, or <code class="language-plaintext highlighter-rouge">Array.to_ary</code> must get called at some point during the instantiation of an array from the literal syntax.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">observe_method</span><span class="p">(</span><span class="no">Kernel</span><span class="p">,</span> <span class="ss">:Array</span><span class="p">)</span>
<span class="n">observe_method</span><span class="p">(</span><span class="no">Array</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">,</span> <span class="ss">:[]</span><span class="p">)</span>
<span class="n">observe_method</span><span class="p">(</span><span class="no">Array</span><span class="p">,</span> <span class="ss">:to_a</span><span class="p">)</span>
<span class="n">observe_method</span><span class="p">(</span><span class="no">Array</span><span class="p">,</span> <span class="ss">:to_ary</span><span class="p">)</span></code></pre></figure> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="go">Array.to_a args:
Array.to_a returns: ["[", "]", "\n"]</span></code></pre></figure> <p>This result, in spite of not being at all what we were seeking or expecting, is very interesting, indeed. We have finally found a method being invoked during the instantiation of an array from the literal syntax, but it is an array containing all the characters from our line of input. Very strange, indeed.</p> <h2 id="becoming-truly-desperate">Becoming Truly Desperate</h2> <p>Desperate times, desperate measures. Looking through the calls to specific functions is all well and good, but does not give a holistic enough picture of what is actually happening. Perhaps, we should observe every single method call on every single object and class in the entire <code class="language-plaintext highlighter-rouge">ObjectSpace</code> of the <code class="language-plaintext highlighter-rouge">Class</code> class. Surely, that will reveal something about array instantiation.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">observe_all_methods</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="n">object</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="nb">method</span><span class="o">|</span> <span class="n">observe_method</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">object</span><span class="p">.</span><span class="nf">methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="nb">method</span><span class="o">|</span> <span class="n">observe_method</span><span class="p">(</span><span class="n">object</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">each_object</span><span class="p">(</span><span class="no">Class</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
  <span class="n">observe_all_methods</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="o">[</span>1]    27580 segmentation fault  irb</code></pre></figure> <p>A not particularly surprising result. If we, however, limit it to the classes of live objects in the session, we do get slightly better results.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">each_object</span><span class="p">().</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">o</span><span class="o">|</span> <span class="n">o</span><span class="p">.</span><span class="nf">class</span> <span class="p">}.</span><span class="nf">uniq</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
  <span class="n">observe_all_methods</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="p">[]</span>
<span class="go">Array#[]= args:
return value is: []
Array#to_a args:
Array#to_s args:
</span><span class="err">
</span><span class="go">[...]
</span><span class="err">
</span><span class="go">return value is: [RubyToken::TkLBRACK]
return value is: [RubyToken::TkLBRACK]
</span><span class="err">
</span><span class="go">[...]
</span><span class="err">
</span><span class="go">return value is: RubyToken::TkLBRACK
Array#[] args:
return value is: RubyToken::TkRBRACK
</span><span class="err">
</span><span class="go">[...]
</span><span class="err">
</span><span class="go">Array#join args:
return value is: []
Array#inspect args:
return value is: []
</span><span class="p">=&gt;</span> <span class="p">[]</span>
<span class="no">Array</span><span class="c1">#empty? args:</span>
<span class="k">return</span> <span class="n">value</span> <span class="ss">is: </span><span class="kp">true</span></code></pre></figure> <p>This is mostly garbage, but there are some interesting snippets amongst the multitude of noise. Maybe we can abuse something in <code class="language-plaintext highlighter-rouge">RubyToken</code> to allow us to intercept (and own) the normal array instantiation process. Unfortunately, this has actually all been a red herring. The <code class="language-plaintext highlighter-rouge">RubyToken</code> module is a part of <span class="fancylink"> <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/irb/rdoc/RubyToken.html"><code class="language-plaintext highlighter-rouge">irb</code></a> <span> <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/irb/rdoc/RubyToken.html" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>, which we conveniently neglected to mention are using to test the various examples. We get no useful output trying the same hacks from within a ruby script, and get different ones when we use <code class="language-plaintext highlighter-rouge">pry</code>. The one glimmer of hope was naught but the interactive shell processing our commands.</p> <h2 id="some-final-probes">Some Final Probes</h2> <p>There are a couple more things we can try, but few avenues remain. We can look at what Ruby does to our input string using <code class="language-plaintext highlighter-rouge">Ripper</code>, but that is not of any real value in this case.</p> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="nb">require</span> <span class="s1">'ripper'</span>
<span class="p">=&gt;</span> <span class="kp">true</span>
<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="no">Ripper</span><span class="p">.</span><span class="nf">lex</span><span class="p">(</span><span class="s2">"[]"</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="ss">:on_lbracket</span><span class="p">,</span> <span class="s2">"["</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="ss">:on_rbracket</span><span class="p">,</span> <span class="s2">"]"</span><span class="p">]]</span>
<span class="gp">&gt;&gt;</span><span class="w"> </span><span class="no">Ripper</span><span class="p">.</span><span class="nf">sexp_raw</span><span class="p">(</span><span class="s2">"[]"</span><span class="p">)</span>
<span class="p">=&gt;</span> <span class="p">[</span><span class="ss">:program</span><span class="p">,</span> <span class="p">[</span><span class="ss">:stmts_add</span><span class="p">,</span> <span class="p">[</span><span class="ss">:stmts_new</span><span class="p">],</span> <span class="p">[</span><span class="ss">:array</span><span class="p">,</span> <span class="kp">nil</span><span class="p">]]]</span></code></pre></figure> <p>A more insightful approach could be to use <code class="language-plaintext highlighter-rouge">Kernel#set_trace_func</code> to see exactly what happens internally during array instantiation.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">set_trace_func</span><span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="nb">binding</span><span class="p">,</span> <span class="n">classname</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">printf</span> <span class="s2">"%8s %-2d %10s %8s</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">classname</span>
<span class="p">},)</span>

<span class="p">[]</span></code></pre></figure> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">c-return 1  set_trace_func   Kernel
    line 5</span></code></pre></figure> <p>Here we see only one <code class="language-plaintext highlighter-rouge">line</code> event occurring on line 5, where the array is instantiated. This is the final dead end.</p> <h2 id="conclusions">Conclusions</h2> <p>With no other avenues to explore, we must concede defeat. At some point, Ruby really must be just magic. Realistically, of course, what appears to be happening is quite the opposite. We have found a situation where Ruby is not as flexible as we would like it to be (N.B. this is not pejorative). In the end, our little edifice is built atop C, and we cannot always manipulate all aspects of our Ruby code in ways that are stupid or downright dangerous. Fortunately, this exploration was not entirely in vain, for we learned about a few interesting features of Ruby and the point at which you can no longer bend the language.</p> <span class="post-date">26 Feb 2015</span> </div> <div class="related"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <h3> <a href="/2018/01/03/privacy-and-exposure-gatekeeprs-and-privileged-consumers/"> Privacy and Exposure, Gatekeepers and Privileged Consumers <small>03 Jan 2018</small> </a> </h3> </li> <li> <h3> <a href="/2017/06/05/common-table-expressions-in-activerecord-a-case-study-of-quantiles/"> Common Table Expressions in ActiveRecord: A Case Study of Quantiles <small>05 Jun 2017</small> </a> </h3> </li> <li> <h3> <a href="/2017/06/18/on-maintainability-gold-plating-the-game-of-life-in-elm/"> On Maintainability: Gold Plating the Game of Life in Elm <small>18 Jun 2017</small> </a> </h3> </li> </ul> </div> <p class="bitcoin"></p> </div> </body> </html>