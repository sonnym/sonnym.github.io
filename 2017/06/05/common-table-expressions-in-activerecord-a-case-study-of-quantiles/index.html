<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us"> <head> <script async src="https://www.googletagmanager.com/gtag/js?id=G-3N6CESJ0B5"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-3N6CESJ0B5");</script> <link href="http://gmpg.org/xfn/11" rel="profile"> <meta http-equiv="content-type" content="text/html; charset=utf-8"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"> <link rel="manifest" href="/site.webmanifest"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"> <title> Common Table Expressions in ActiveRecord: A Case Study of Quantiles &middot; effluence </title> <link rel="stylesheet" href="/assets/css/styles.css"> <link rel="preconnect" href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Epilogue&display=swap" rel="stylesheet"> <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml"> <link rel="canonical" href="https://sonnym.com/2017/06/05/common-table-expressions-in-activerecord-a-case-study-of-quantiles/"> </head> <body class="layout-reverse"> <div class="sidebar"> <div class="container sidebar-sticky"> <div class="sidebar-about"> <h1>effluence</h1> <p class="lead"></p> </div> <ul class="sidebar-nav"> <li class="sidebar-nav-item"> <a href="/">home</a> </li> <li class="sidebar-nav-item"> <a href="/about/">about</a> </li> <li class="sidebar-nav-item"> <a href="/atom.xml" target="_blank">rss</a> </li> </ul> <p>&copy; 2026. All rights reserved.</p> </div> </div> <div class="content container"> <div class="post"> <h1 class="post-title">Common Table Expressions in ActiveRecord: A Case Study of Quantiles</h1> <h2 id="framing">Framing</h2> <p>Today, we are going to look at a straightforward real-world problem, and build a comprehensive solution. In doing so, we will start with some various naive approaches as we increase our understanding of the underlying mechanics, encounter some pitfalls, and, ultimately, approach a reasonable level of sophistication and abstraction. The stack we will be using for this case study is <span class="fancylink"> <a href="http://rubyonrails.org/">Ruby on Rails 5.1</a> <span> <a href="http://rubyonrails.org/" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> with <span class="fancylink"> <a href="https://www.postgresql.org/">PostgreSQL 9.6</a> <span> <a href="https://www.postgresql.org/" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> for the database.</p> <p>Now, let me present to you the problem through which we will frame this discussion: given a number of student records, when displaying a single student, also display the quintile into which their grade falls.</p> <h2 id="calculating-quantiles-in-postgresql">Calculating Quantiles in PostgreSQL</h2> <p>Let us begin by looking at the structure of our <code class="language-plaintext highlighter-rouge">students</code> table. The following was generated with a simple Rails migration, the details of which are outside the scope of this article. The table, intentionally simple for the purpose of illustration, only has columns for an <code class="language-plaintext highlighter-rouge">id</code>, a <code class="language-plaintext highlighter-rouge">name</code>, and a <code class="language-plaintext highlighter-rouge">grade</code>.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># \d students
                              Table "public.students"
 Column |       Type        |                       Modifiers
--------+-------------------+-------------------------------------------------------
 id     | bigint            | not null default nextval('students_id_seq'::regclass)
 name   | character varying | not null
 grade  | integer           | not null
Indexes:
    "students_pkey" PRIMARY KEY, btree (id)</code></pre></figure> <p>In order to have some data to work with, we want to generate some at random. We use the following command to create a million records with grades between 0 and</p> <ol> <li>As you can see from the subsequent queries, we now have a corpus upon which to operate. Since we are working with a million rows, we know each quintile contains 200,000 records, and we can safely assume that they will be split fairly close to multiples of 20. We will soon be able to confirm this assumption.</li> </ol> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># insert into students (name, grade)
select
  left(md5(i::text), 10),
  (random()*100)::int
from generate_series(1, 1000000) s(i);
INSERT 0 1000000</code></pre></figure> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># select count(*) from students;
  count
  ---------
   1000000
   (1 row)</code></pre></figure> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># select * from students limit 10;
 id |    name    | grade
----+------------+-------
  1 | c4ca4238a0 |    29
  2 | c81e728d9d |    87
  3 | eccbc87e4b |    26
  4 | a87ff679a2 |    43
  5 | e4da3b7fbb |    59
  6 | 1679091c5a |    44
  7 | 8f14e45fce |    53
  8 | c9f0f895fb |     4
  9 | 45c48cce2e |    81
 10 | d3d9446802 |    12
(10 rows)</code></pre></figure> <p>In order to calculate quantiles, we will be making use of a PostgreSQL feature called <span class="fancylink"> <a href="https://www.postgresql.org/docs/9.6/static/tutorial-window.html">window functions</a> <span> <a href="https://www.postgresql.org/docs/9.6/static/tutorial-window.html" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>. Using the <span class="fancylink"> <a href="https://www.postgresql.org/docs/9.6/static/functions-window.html"><code class="language-plaintext highlighter-rouge">ntile()</code></a> <span> <a href="https://www.postgresql.org/docs/9.6/static/functions-window.html" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> function, it is actually fairly trivial to calculate the quintile for a row. As can be seen in the following query, this is the case so long as we use a <code class="language-plaintext highlighter-rouge">limit</code> clause to only return one row. Using the <span class="fancylink"> <a href="https://www.postgresql.org/docs/9.6/static/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">window function call syntax</a> <span> <a href="https://www.postgresql.org/docs/9.6/static/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>, we define a computed column <code class="language-plaintext highlighter-rouge">quintile</code> using <code class="language-plaintext highlighter-rouge">ntile(5)</code> over the grade column, ordered.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># select *, ntile(5) over (order by grade) as quintile from students order by id limit 1;
  id |    name    | grade | quintile
 ----+------------+-------+----------
   1 | c4ca4238a0 |    29 |        2
   (1 row)</code></pre></figure> <p>But something interesting happens when we try to use a <code class="language-plaintext highlighter-rouge">where</code> clause to get the same result: we get a different, incorrect, result. This is because window functions operate over the set of records returned by the <code class="language-plaintext highlighter-rouge">from/where</code> clause, so, in this next case, only sees one record. This makes our current query useless, since we are under the constraint of needing to display the quintile for a specific record.</p> <p>At this point, it would also be nice to confirm that our data has the expected shape, but we run into another interesting limitation: namely, that we cannot use window functions inside the <code class="language-plaintext highlighter-rouge">group by</code> clause.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># select *, ntile(5) over (order by grade) as quintile from students where id = 1;
 id |    name    | grade | quintile
----+------------+-------+----------
  1 | c4ca4238a0 |    29 |        1
(1 row)</code></pre></figure> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># select count(*), ntile(5) over (order by grade) as quintile from students group by quintile;
ERROR:  window functions are not allowed in GROUP BY
LINE 1: select count(*), ntile(5) over (order by grade) as quintile ...
                         ^</code></pre></figure> <p>Luckily, SQL queries, generally speaking, can often be reshaped into a form that is sufficient for our needs. In particular, we can use another feature of PostgreSQL to work around these early teething problems: <span class="fancylink"> <a href="https://www.postgresql.org/docs/9.6/static/queries-with.html">common table expressions, aka <code class="language-plaintext highlighter-rouge">with</code> queries</a> <span> <a href="https://www.postgresql.org/docs/9.6/static/queries-with.html" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>.</p> <p>Using a common table expression, we generate a temporary table for the duration of this query. This table will contain our quintile value, and we will pull the data from it. For now, we will just call it <code class="language-plaintext highlighter-rouge">quintile_table</code>. As an aside, it is worthwhile to note that common table expressions are also capable of significantly more advanced features, including iteration (albeit invoked using the <code class="language-plaintext highlighter-rouge">recursive</code> keyword), but we need not concern ourselves with those details here.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># with quintile_table as (select *, ntile(5) over (order by grade) as quintile from students)
	select * from quintile_table where id = 1;
 id |    name    | grade | quintile
----+------------+-------+----------
  1 | c4ca4238a0 |    29 |        2
(1 row)</code></pre></figure> <p>That query gave us exactly the output we desire. The current shape of the query also conveys upon us the ability to cheat the restriction of not being able to use window functions in a <code class="language-plaintext highlighter-rouge">group by</code> clause, since we are now grouping on a column from the temporary table, and PostgreSQL treats this like any other column. As evidenced in the following query, the data looks exactly how we expected.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># with quintile_table as (select *, ntile(5) over (order by grade) as quintile from students)
	select count(*), min(grade) as min, max(grade) as max, quintile
	from quintile_table group by quintile order by quintile;
 count  | min | max | quintile
--------+-----+-----+----------
 200000 |   0 |  20 |        1
 200000 |  20 |  40 |        2
 200000 |  40 |  60 |        3
 200000 |  60 |  80 |        4
 200000 |  80 | 100 |        5
(5 rows)</code></pre></figure> <p>The added layer of complexity, necessary to allow us to filter on an arbitrary <code class="language-plaintext highlighter-rouge">where</code> clause should be expected to increase the computational cost of the query, but that is actually not the case in a substantial way. The start-up cost for the query using common table expressions is less (by 5000) than that of the naive query using a <code class="language-plaintext highlighter-rouge">limit</code> clause, which means the output phase should be expected to actually begin earlier. True, the total cost is more by 17499.99, but that seems like a slight cost to pay in order to get the desired result from amongst a million records.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># explain select *, ntile(5) over (order by grade) as quintile from students order by id limit 1;
                                        QUERY PLAN
-------------------------------------------------------------------------------------------
 Limit  (cost=159037.84..159037.85 rows=1 width=27)
   -&gt;  Sort  (cost=159037.84..161537.84 rows=1000000 width=27)
         Sort Key: id
         -&gt;  WindowAgg  (cost=136537.84..154037.84 rows=1000000 width=27)
               -&gt;  Sort  (cost=136537.84..139037.84 rows=1000000 width=23)
                     Sort Key: grade
                     -&gt;  Seq Scan on students  (cost=0.00..16370.00 rows=1000000 width=23)
(7 rows)</code></pre></figure> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># explain with quintile_table as (select *, ntile(5) over (order by grade) as quintile from students)
  select * from quintile_table where id = 1;
                                      QUERY PLAN
---------------------------------------------------------------------------------------
 CTE Scan on quintile_table  (cost=154037.84..176537.84 rows=5000 width=48)
   Filter: (id = 1)
   CTE quintile_table
     -&gt;  WindowAgg  (cost=136537.84..154037.84 rows=1000000 width=27)
           -&gt;  Sort  (cost=136537.84..139037.84 rows=1000000 width=23)
                 Sort Key: students.grade
                 -&gt;  Seq Scan on students  (cost=0.00..16370.00 rows=1000000 width=23)
(7 rows)</code></pre></figure> <p>It is worthwhile to note, before going any further, that this method would not be sufficiently performant in a production environment for a data set of this size; some caching or precomputation layer would be necessary, but that is outside the scope of this article.</p> <h2 id="integrating-into-rails">Integrating into Rails</h2> <p>At this point, we have a query that can handle arbitrary filtering, but we want to use it within an <code class="language-plaintext highlighter-rouge">ActiveRecord</code> model. The first thought may be that we can simply use <span class="fancylink"> <a href="http://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select">ActiveRecord::QueryMethods#select</a> <span> <a href="http://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>, but we are about to take a step backwards.</p> <p>(N.B. We break down the long SQL string into separate clauses using an array and joining it back into a string for the query; while this may not be the best practice, it is a sufficient way to break up long chunks of SQL when prototyping.)</p> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="nb">puts</span> <span class="no">Student</span><span class="o">.</span>
<span class="go">?&gt; select([
?&gt;   'with quintile_table',
?&gt;   'as (select *, ntile(5) over (order by grade)',
?&gt;   'as quintile from students)'
?&gt; ].join(' ')).
?&gt; to_sql
SELECT with quintile_table as (select *, ntile(5) over (order by grade) as quintile from students) FROM "students"</span></code></pre></figure> <p>The result is, again, not what we desire, and we must step back. Actually reading the documentation for the <code class="language-plaintext highlighter-rouge">select</code> method, we see it takes a list of fields we wish to select, but does not overwrite the entire <code class="language-plaintext highlighter-rouge">select</code> clause, as we (with intentional naivete) assumed. Instead, we will have to again reshape the query into a way that will allow for composability within the constraints of an <code class="language-plaintext highlighter-rouge">ActiveRecord</code> model.</p> <p>Thinking in terms of how we compose queries using scopes in Rails, it may be best to define our optimal interface before going forward. In this case, a standalone <code class="language-plaintext highlighter-rouge">with_quintile</code> scope would be optimal, and we would want to be able to use it just like any other scope, with its internals abstracted. Consider the following: <code class="language-plaintext highlighter-rouge">Student.with_quintile.where(id: 1).first.quintile</code></p> <p>In order to achieve this result, we will need to abandon our attempts to manipulate the <code class="language-plaintext highlighter-rouge">select</code> clause to our ends and, instead, focus on the <code class="language-plaintext highlighter-rouge">from</code> clause. Very simply, we can alias our original <code class="language-plaintext highlighter-rouge">quintile_table</code> as <code class="language-plaintext highlighter-rouge">students</code>, the <code class="language-plaintext highlighter-rouge">table_name</code> of our table, thereby tricking all other normal scopes into being well behaved in its presence. As far as they are concerned, the <code class="language-plaintext highlighter-rouge">students</code> table has the <code class="language-plaintext highlighter-rouge">quintile</code> column there at all times.</p> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="no">Student</span><span class="o">.</span>
<span class="go">?&gt; from([
?&gt;  '(with "quintile_table"',
?&gt;  'as (select *, ntile(5) over (order by grade)',
?&gt;  'as quintile from "students") select * from "quintile_table")',
?&gt;  'as "students"'
?&gt; ].join(' ')).
?&gt; where(id: 1).
?&gt; first.
?&gt; quintile
  Student Load (672.7ms)  SELECT  "students".* FROM (with "quintile_table" as (select *, ntile(5) over (order by grade) as quintile from "students") select * from "quintile_table") as "students" WHERE "students"."id" = $1 ORDER BY "students"."id" ASC LIMIT $2  [["id", 1], ["LIMIT", 1]]
</span><span class="p">=&gt;</span> <span class="mi">2</span></code></pre></figure> <p>It would, again, be reasonable to believe additional misdirection such as this would increase the cost of the query, but the <code class="language-plaintext highlighter-rouge">limit</code> clause added by the call to <code class="language-plaintext highlighter-rouge">ActiveRecord::FinderMethods#first</code> effectively reduces the total cost back to the initial value.</p> <figure class="highlight"><pre><code class="language-psql" data-lang="psql"># explain
  select "students".*
  from (with "quintile_table"
        as (select *, ntile(5)
        over (order by grade) as quintile
        from "students")
    select * from "quintile_table") as "students"
  where "students"."id" = 1
  order by "students"."id" asc
  limit 1;
                                         QUERY PLAN
---------------------------------------------------------------------------------------------
 Limit  (cost=154037.84..154042.35 rows=1 width=48)
   -&gt;  CTE Scan on quintile_table  (cost=154037.84..176537.84 rows=5000 width=48)
         Filter: (id = 1)
         CTE quintile_table
           -&gt;  WindowAgg  (cost=136537.84..154037.84 rows=1000000 width=27)
                 -&gt;  Sort  (cost=136537.84..139037.84 rows=1000000 width=23)
                       Sort Key: students.grade
                       -&gt;  Seq Scan on students  (cost=0.00..16370.00 rows=1000000 width=23)
(8 rows)</code></pre></figure> <h2 id="achieving-modularity-using-arel">Achieving Modularity Using AREL</h2> <p>We can now say that we have gotten to a point where we can simply wrap what we have in a scope, and call it good. Were this a feature for a client on a time sensitive project, I would probably agree; but we can certainly do better than the following.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Student</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:with_quintile</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span>
    <span class="n">from</span><span class="p">([</span>
      <span class="s1">'(with "quintile_table" as (select *, ntile(5)'</span><span class="p">,</span>
      <span class="s1">'over (order by grade) as quintile from "students")'</span><span class="p">,</span>
      <span class="s1">'select * from "quintile_table") as "students"'</span>
    <span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="s1">' '</span><span class="p">))</span>
  <span class="p">}</span>
<span class="k">end</span></code></pre></figure> <p>Normally, it is <span class="fancylink"> <a href="https://gist.github.com/ryanb/4172391">considered bad practice</a> <span> <a href="https://gist.github.com/ryanb/4172391" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> to hide complexity within modules, so the following is not inherently a recommendation, so much as an elaboration on how we would approach generalizing what we already have. On the other hand, having worked on large, long-lived projects, I cannot stress enough the maintenance issues caused by having pieces of hard-coded SQL strewn within model classes. As such, the conversion to use <span class="fancylink"> <a href="https://github.com/rails/arel">AREL</a> <span> <a href="https://github.com/rails/arel" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span> is an explicit recommendation.</p> <p>Here, we create a new <code class="language-plaintext highlighter-rouge">ActiveSupport::Concern</code> module in <code class="language-plaintext highlighter-rouge">app/models/concerns/quintile.rb</code>, which we will include in any class we want to be able to call our scope on. In this case, we have removed any explicit to both the table name or the column we are using as our calculation. Consequently, this module can already be included any <code class="language-plaintext highlighter-rouge">ActiveRecord</code> model, its <code class="language-plaintext highlighter-rouge">quintile_on</code> class macro used, and that is all that is necessary to add a scope for calculating a quintile on a given column. In this particular case, we could have simply defined all the methods within the <code class="language-plaintext highlighter-rouge">class_methods</code> block in the module within the <code class="language-plaintext highlighter-rouge">Student</code> class itself, thereby obviating the extraneous module.</p> <p>Ultimately, the version written with AREL produces the exact same output, but with a lot of the hard-coded aspects stripped away. While it is more difficult to write up front, and more difficult to follow, each method returns an object that is an <code class="language-plaintext highlighter-rouge">Arel::Node</code>, which has a <code class="language-plaintext highlighter-rouge">to_sql</code> method. When composing queries in this way for a real production application, this makes it possible to very easily test the SQL generated, helping with long-term maintenance.</p> <figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Quintile</span>
  <span class="kp">extend</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Concern</span>

  <span class="n">class_methods</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">quintile_on</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="n">scope</span> <span class="s2">"with_quintile_on_</span><span class="si">#{</span><span class="n">column</span><span class="si">}</span><span class="s2">"</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="n">from</span><span class="p">(</span><span class="n">wrapped_quintile_query</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
      <span class="p">}</span>
    <span class="k">end</span>

    <span class="kp">private</span>

    <span class="k">def</span> <span class="nf">wrapped_quintile_query</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">quintile_query</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">arel_table</span><span class="p">).</span><span class="nf">to_sql</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">quintile_query</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="n">table</span> <span class="o">=</span> <span class="n">quintile_table</span>

      <span class="n">table</span><span class="p">.</span>
        <span class="nf">project</span><span class="p">(</span><span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'*'</span><span class="p">)).</span>
        <span class="nf">with</span><span class="p">(</span><span class="n">quintile_cte</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">quintile_table</span>
      <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"quintile_table_for_</span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">_</span><span class="si">#{</span><span class="no">SecureRandom</span><span class="p">.</span><span class="nf">hex</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">quintile_cte</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
      <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Window</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">window</span><span class="o">|</span>
        <span class="n">window</span><span class="p">.</span><span class="nf">framing</span> <span class="o">=</span> <span class="n">quintile_cte_select</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
      <span class="k">end</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">quintile_cte_select</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
      <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SelectCore</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="nb">select</span><span class="o">|</span>
        <span class="nb">select</span><span class="p">.</span><span class="nf">projections</span> <span class="o">=</span> <span class="p">[</span>
          <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'*'</span><span class="p">),</span>

          <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">As</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
            <span class="n">quintile_cte_over</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'quintile'</span><span class="p">)</span>
          <span class="p">)</span>
        <span class="p">]</span>
        <span class="nb">select</span><span class="p">.</span><span class="nf">from</span> <span class="o">=</span> <span class="n">arel_table</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">quintile_cte_over</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Over</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
        <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'ntile(5)'</span><span class="p">),</span>
        <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Window</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Student</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="kp">include</span> <span class="no">Quintile</span>

  <span class="n">quintile_on</span> <span class="ss">:grade</span>
<span class="k">end</span></code></pre></figure> <p>As can be seen in our usage of the <code class="language-plaintext highlighter-rouge">Student</code> below, the named scope generated by our class macro have a more fluent name than we had used previously, namely stating on which column the quintile is being processed. Another point of interest for the query generated is our choice to define the <code class="language-plaintext highlighter-rouge">quintile_table</code> method, such that it includes a random value in the name, with the intent of making name collisions less likely when working with other scopes that require table aliases.</p> <figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="gp">&gt;&gt;</span><span class="w"> </span><span class="no">Student</span><span class="p">.</span><span class="nf">with_quintile_on_grade</span><span class="p">.</span><span class="nf">first</span>
<span class="go">   Student Load (928.2ms)  SELECT  "students".* FROM (WITH "quintile_table_for_students_b886c9319a75c9eb" AS (SELECT *, ntile(5) OVER (ORDER BY grade) AS quintile FROM "students") SELECT * FROM "quintile_table_for_students_b886c9319a75c9eb") AS "students" ORDER BY "students"."id" ASC LIMIT $1  [["LIMIT", 1]]
</span><span class="p">=&gt;</span> <span class="kt">#&lt;</span><span class="no">Student</span><span class="p">:</span><span class="mh">0x0055d3e736a518</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">name: </span><span class="s2">"c4ca4238a0"</span><span class="p">,</span> <span class="ss">grade: </span><span class="mi">29</span><span class="kt">&gt;</span></code></pre></figure> <h2 id="toward-a-robust-dsl">Toward a Robust DSL</h2> <p>While this is a perfectly reasonable stopping point for this project, having gotten exactly what we need from the database within the confines of a Rails application, there is a lot more we could do. It is easy to imagine, from atop our module specific to quintiles for columns, writing a much more robust system for defining these sorts of calculations. The next logical steps are fairly clear:</p> <ol> <li>Abstract out the <code class="language-plaintext highlighter-rouge">quintile</code> aspect of the library, for the ability to have any quantile.</li> <li>Create an class to encapsulate information about the <code class="language-plaintext highlighter-rouge">table</code> and <code class="language-plaintext highlighter-rouge">column</code>, to prevent the constant use as parameters.</li> <li>Implement higher order class macros that can handle multiple definitions at once.</li> </ol> <p>Now, <code class="language-plaintext highlighter-rouge">ActiveSUpport::Inflector</code> may not deal in quantiles, but it would be easy enough to possess our own mapping between integers and words. But all of this is mere speculation, for we have accomplished what we set out to do. Perhaps we will someday return to this, but, for now, that is enough implementation.</p> <h2 id="ruminations">Ruminations</h2> <p>Instead, the path upon which we have trod during this exercise gives us a contextual vantage point from which to discuss software construction, methodology, and practice more generally. We started as “close to the metal” as necessary—inside PostgreSQL—but not at a layer so far away from our problem domain that we would lose sight of goal. In doing so, we learned about and utilized some less common features of the database in an environment that was conducive to exploring this fundamentals. Had we started from ActiveRecord, or worse AREL, our feedback loop would have been much slower as we coped with extraneous details. Instead, we did the simplest thing we could, found the points at which it broke down, and iterated our implementation before even attempting to integrate it. And when we did so, we had to step back, and reiterate the process, given our new set of constraints.</p> <p>Often times, a problem will appear intractable when approached at too high a level, without enough granular control, or without enough understanding of the underlying architecture. Stepping down helps in these cases, but does not produce a satisfactory result. After having gleaned what we could from the database itself, we had to climb back up the <span class="fancylink"> <a href="http://worrydream.com/LadderOfAbstraction/">ladder of abstraction</a> <span> <a href="http://worrydream.com/LadderOfAbstraction/" target="_blank" alt="Pop Out" title="Pop Out"><svg class="octicon octicon-link-external" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M3.75 2h3.5a.75.75 0 0 1 0 1.5h-3.5a.25.25 0 0 0-.25.25v8.5c0 .138.112.25.25.25h8.5a.25.25 0 0 0 .25-.25v-3.5a.75.75 0 0 1 1.5 0v3.5A1.75 1.75 0 0 1 12.25 14h-8.5A1.75 1.75 0 0 1 2 12.25v-8.5C2 2.784 2.784 2 3.75 2Zm6.854-1h4.146a.25.25 0 0 1 .25.25v4.146a.25.25 0 0 1-.427.177L13.03 4.03 9.28 7.78a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l3.75-3.75-1.543-1.543A.25.25 0 0 1 10.604 1Z"></path></svg></a> </span> </span>. In doing so, we went marginally further than necessary, but showed how we could remove a lot of the hard-coded details and make our software more robust. We had the opportunity to stop, but favored the more complete approach. In languages with code generation deeply ingrained, our solutions will often grow to involve a level of abstraction that makes reuse trivial. When it is overkill and when it is ideal is a much more subjective question, based more on the exigencies of the real world rather than what would be considered optimal from a software implementation perspective.</p> <p>And, finally, to get to the meta and talk about this last section from within itself; it is always important to step back after an exercise that touches many different pieces, contrived or experienced in practice, and ponder about what can be gleaned from the process. Just as higher order abstractions in programming come from the recognition of patterns, so does it arise in higher order thinking about programming.</p> <span class="post-date">05 Jun 2017</span> </div> <div class="related"> <h2>Related Posts</h2> <ul class="related-posts"> <li> <h3> <a href="/2018/01/03/privacy-and-exposure-gatekeeprs-and-privileged-consumers/"> Privacy and Exposure, Gatekeepers and Privileged Consumers <small>03 Jan 2018</small> </a> </h3> </li> <li> <h3> <a href="/2017/06/18/on-maintainability-gold-plating-the-game-of-life-in-elm/"> On Maintainability: Gold Plating the Game of Life in Elm <small>18 Jun 2017</small> </a> </h3> </li> <li> <h3> <a href="/2018/11/19/types-in-elm-decomposition-and-ad-hoc-polymorphism/"> Types in Elm: Decomposition and Ad Hoc Polymorphism <small>19 Nov 2018</small> </a> </h3> </li> </ul> </div> <p class="bitcoin"></p> </div> </body> </html>